# Reference:
# https://hackernoon.com/deployment-of-full-scale-elk-stack-to-kubernetes-6f38f6c57c55
# https://github.com/ITSvitCo/aws-k8s/tree/master/kubernetes-manifests/monitoring
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: logstash
  namespace: monitoring
data:
  logstash.conf: |-
    input {
      beats {
        port => 5044
      }
    }

    filter {
      mutate { replace => { "producer" => "cmswebk8s" } }
      ruby {
          code => "event.set('logtime',(event.get('@timestamp').to_f * 1000).to_i)"
      }
      # for message output we need to replace nested objects
      mutate {
          add_field => {
              "hostname" => "%{[agent][hostname]}"
              "agent_id" => "%{[agent][id]}"
              "ephemeral_id" => "%{[agent][ephemeral_id]}"
              "cmsweb_log" => "%{[log][file][path]}"
        }
      }
      if "frontend" in [tags] {
          mutate { replace => { "type" => "frontend" } }

          # capture apache records
          # https://github.com/elastic/logstash/blob/v1.4.2/patterns/grok-patterns
          # example of cmsweb apache entry
          #[10/Mar/2019:00:59:59 +0100] cmsweb.cern.ch 137.138.152.31 "GET /reqmgr2/data/request?name=vlimant_ACDC0_task_B2G-RunIIFall17wmLHEGS-00607__v1_T_190304_194213_4399 HTTP/1.1" 200 [data: 3044 in 29413 out 11256 body 70659 us ] [auth: TLSv1.2 ECDHE-RSA-AES128-GCM-SHA256 "/DC=ch/DC=cern/OU=computers/CN=wmagent/vocms0308.cern.ch" "-" ] [ref: "-" "WMCore.Services.Requests/v001" ]

          grok {
            match => { "message" => '\[%{HTTPDATE:tstamp}\] %{DATA:frontend} %{IPORHOST:clientip} "%{WORD:method} %{NOTSPACE:request} %{DATA:httpversion}" %{NUMBER:code:int} \[data:.*\] \[auth: %{DATA:tls} %{DATA:crypto} "%{DATA:dn}".*\] \[ref: "%{DATA}.*" "%{DATA:client}" \]' }
          }
          grok {
             match => { "request" => '/%{WORD:system}%{UNIXPATH:uri_path}%{URIPARAM:uri_params}?' }
          }
          if [uri_params] {
              grok {
                 match => { "uri_path" => '/.*/%{DATA:api}$' }
              }
              if [api] == "" {
                  grok {
                     match => { "uri_path" => '/.*/%{DATA:api}/$' }
                  }
              }
          } else {
              grok {
                 match => { "request" => '/.*/%{DATA:api}$' }
              }
              if [api] == "" {
                  grok {
                     match => { "request" => '/.*/%{DATA:api}/$' }
                  }
              }
              # mutate { replace => { "api" => "" } }
          }
          if [uri_params] and ![api] {
              grok {
                 match => { "uri_path" => '/.*/%{DATA:api}/$' }
              }
          }
          if ![api] {
              mutate { replace => { "api" => "%{request}" } }
              mutate { replace => { "system" => "%{request}" } }
          }
          # https://www.elastic.co/guide/en/logstash/current/plugins-filters-date.html
          # date string example: [10/Mar/2019:00:59:59 +0100]
          date {
             match => [ "tstamp", "dd/MMM/yyyy:HH:mm:ss Z" ]
             target => "date_object"
          }
          ruby {
             code => "event.set('rec_timestamp',event.get('date_object').to_i)
                      event.set('rec_date',event.get('date_object'))
                     "
          }

          #Remove the numeric CNs from the client dn.
          mutate { gsub =>  [ "dn","/CN=\d+","" ] }
          # check if we produce any parsing errors
          if "_grokparsefailure" in [tags] {
              mutate { add_field => {"frontend_error" => "parser-error" } }
          } else {
              mutate { add_field => {"frontend_error" => "" } }
          }
      } # end of if statement checking tags

      # here we can check any other service by using this statement
      if "acdcserver" in [tags] {
          mutate { replace => { "type" => "acdcserver" } }
      }
      if "confdb" in [tags] {
          mutate { replace => { "type" => "confdb" } }
      }
      if "couchdb" in [tags] {
          mutate { replace => { "type" => "couchdb" } }
          # example of log entry
          # [Mon, 14 Oct 2019 14:39:59 GMT] [info] [<0.26674.38>] 127.0.0.1 - - GET /workqueue/_design/WorkQueue/index.html 200
          grok {
              match => { "message" => '\[%{GREEDYDATA:tstamp}\] \[%{WORD:log_level}\] \[<.*>\] %{IPORHOST:clientip} - - %{WORD:method} %{NOTSPACE:request} %{NUMBER:code:int}' }
          }
          grok {
              match => { "request" => '/%{WORD:system}%{UNIXPATH:uri_path}%{URIPARAM:uri_params}?' }
          }
          grok {
              match => { "uri_path" => '/.*/%{DATA:api}$' }
          }
          # https://www.elastic.co/guide/en/logstash/current/plugins-filters-date.html
          # date string example: [10/Mar/2019:21:42:53]
          date {
             match => [ "tstamp", "EEE, dd MMM yyyy HH:mm:ss z" ]
             target => "date_object"
          }
          ruby {
             code => "event.set('rec_timestamp',event.get('date_object').to_i)
                      event.set('rec_date',event.get('date_object'))
                     "
          }
          #Remove the numeric CNs from the client dn.
          mutate { gsub =>  [ "dn","/CN=\d+","" ] }
          # check if we produce any parsing errors
          if "_grokparsefailure" in [tags] {
              mutate { add_field => {"couchdb_error" => "parser-error" } }
          } else {
              mutate { add_field => {"couchdb_error" => "" } }
          }
      }
      if "crabserver" in [tags] {
          mutate { replace => { "type" => "crabserver" } }
      }
      if "dbs" in [tags] {
          mutate { replace => { "type" => "dbs" } }
          # example of log entry
          # INFO:cherrypy.access:[10/Mar/2019:21:42:53] vocms0136.cern.ch 128.142.35.219 "GET /dbs/prod/global/DBSReader/datasets?dataset_access_type=%2A&detail=1&dataset=%2FGluGluHToZZTo2L2Nu_M2500_13TeV_powheg2_JHUGenV7011_pythia8%2FRunIIAutumn18NanoAOD-102X_upgrade2018_realistic_v15-v1%2FNANOAODSIM HTTP/1.1" 200 OK [data: - in 753 out 3711 us ] [auth: OK "/DC=ch/DC=cern/OU=Organic Units/OU=Users/CN=dmytro/CN=658085/CN=Dmytro Kovalskyi" "" ] [ref: "" "PycURL/7.19.7" ]

          grok {
              match => { "message" => '.*\[%{NOTSPACE:tstamp}\] %{DATA:backend} %{IPORHOST:clientip} "%{WORD:method} %{NOTSPACE:request} %{DATA:httpversion}" %{NUMBER:code:int} %{WORD:status} \[data:.*\] \[auth: %{WORD:auth} "%{DATA:dn}" "%{DATA}.*" \] \[ref: "%{DATA}.*" "%{DATA:client_agent}" \]' }
          }
          grok {
              match => { "request" => '/dbs/%{WORD:instance}/%{WORD:instance_type}/DBSReader/%{WORD:api}?%{DATA:params}' }
          }
          # https://www.elastic.co/guide/en/logstash/current/plugins-filters-date.html
          # date string example: [10/Mar/2019:21:42:53]
          date {
             match => [ "tstamp", "dd/MMM/yyyy:HH:mm:ss" ]
             target => "date_object"
          }
          ruby {
             code => "event.set('rec_timestamp',event.get('date_object').to_i)
                      event.set('rec_date',event.get('date_object'))
                     "
          }
          #Remove the numeric CNs from the client dn.
          mutate { gsub =>  [ "dn","/CN=\d+","" ] }
          # check if we produce any parsing errors
          if "_grokparsefailure" in [tags] {
              mutate { add_field => {"dbs_error" => "parser-error" } }
          } else {
              mutate { add_field => {"dbs_error" => "" } }
          }
      }
      if "das" in [tags] {
          mutate { replace => { "type" => "das" } }
      }
      if "dqmgui" in [tags] {
          mutate { replace => { "type" => "dqmgui" } }
      }
      if "phedex" in [tags] {
          mutate { replace => { "type" => "phedex" } }
      }
      if "reqmgr2" in [tags] {
          mutate { replace => { "type" => "reqmgr2" } }
          # example of log entry
          # [15/Oct/2019:02:00:41] reqmgr2-89f7df4fd-95g9q 137.138.54.48 "GET /reqmgr2/data/request?name=amaltaro_TaskChain_NanoAOD_Oct2019_Val_191010_125831_5691 HTTP/1.1" 200 OK [data: 1179 in 1927 out 1337845 us ] [auth: OK "/DC=ch/DC=cern/OU=computers/CN=wmagent/vocms0192.cern.ch" "" ] [ref: "" "WMCore.Services.Requests/v002" ]

          grok {
              match => { "message" => '.*\[%{NOTSPACE:tstamp}\] %{DATA:backend} %{IPORHOST:clientip} "%{WORD:method} %{NOTSPACE:request} %{DATA:httpversion}" %{NUMBER:code:int} %{WORD:status} \[data:.*\] \[auth: %{WORD:auth} "%{DATA:dn}" "%{DATA}.*" \] \[ref: "%{DATA}.*" "%{DATA:client_agent}" \]' }
          }
          # https://www.elastic.co/guide/en/logstash/current/plugins-filters-date.html
          # date string example: [10/Mar/2019:21:42:53]
          date {
             match => [ "tstamp", "dd/MMM/yyyy:HH:mm:ss" ]
             target => "date_object"
          }
          ruby {
             code => "event.set('rec_timestamp',event.get('date_object').to_i)
                      event.set('rec_date',event.get('date_object'))
                     "
          }
          #Remove the numeric CNs from the client dn.
          mutate { gsub =>  [ "dn","/CN=\d+","" ] }
          # check if we produce any parsing errors
          if "_grokparsefailure" in [tags] {
              mutate { add_field => {"reqmgr2_error" => "parser-error" } }
          } else {
              mutate { add_field => {"reqmgr2_error" => "" } }
          }

      }
      if "reqmgr2ms" in [tags] {
          mutate { replace => { "type" => "reqmgr2ms" } }
      }
      if "reqmgr2-tasks" in [tags] {
          mutate { replace => { "type" => "reqmgr2-tasks" } }
      }
      if "reqmon" in [tags] {
          mutate { replace => { "type" => "reqmon" } }
      }
      if "t0_reqmon" in [tags] {
          mutate { replace => { "type" => "t0_reqmon" } }
      }
      if "t0wmadatasvc" in [tags] {
          mutate { replace => { "type" => "t0wmadatasvc" } }
      }
      if "workqueue" in [tags] {
          mutate { replace => { "type" => "workqueue" } }
      }
      if "workqueue-tasks" in [tags] {
          mutate { replace => { "type" => "workqueue-tasks" } }
      }

      # remove quotes from message entry since it will break the JSON
      mutate { gsub => [ "message", "\n", "", "message", "\"", ""] }
      # last part we should remove object fields
      mutate {
          remove_field => ["agent", "log", "input", "tags", "ecs", "host"]
      }

    } # end of the main filter {

    # send results (JSON records) to local file
    # Each records must have the following attributes:
    # "producer":"%{producer}", "type": "%{type}"
    # then we parse all filebeat attributes
    # "hostname": "%{hostname}", "agent_id": "%{agent_id}", "ephemeral_id":
    # "%{ephemeral_id}", "cmsweb_log": "%{cmsweb_log}",
    # followed by log message itself
    # "message": "%{message}"
    output {
      #file {
      #    path => "/tmp/logstash-output.log"
      #}
      if [type] == "frontend" and [frontend_error] == "" {
          http {
              http_method => post
              url => "http://monit-logs.cern.ch:10012/"
              content_type => "application/json; charset=UTF-8"
              format => "message"
              # for message please use double quotes for string type and no-double
              # quotes for objects, e.g. %{agent} is an object, while "%{dn}" is a
              # string
              message => '[{"producer": "cmswebk8s", "type": "frontend", "hostname": "%{hostname}", "agent_id": "%{agent_id}", "ephemeral_id": "%{ephemeral_id}", "cmsweb_log": "%{cmsweb_log}", "message": "%{message}", "api": "%{api}", "client": "%{client}", "clientip": "%{clientip}", "code": %{code}, "crypto": "%{crypto}", "date_object": "%{date_object}", "dn": "%{dn}", "frontend": "%{frontend}", "httpversion": "%{httpversion}", "method": "%{method}", "rec_date": "%{rec_date}", "rec_timestamp": %{rec_timestamp}, "request": "%{request}", "system": "%{system}", "tls": "%{tls}", "tstamp": "%{tstamp}", "uri_params": "%{uri_params}", "uri_path": "%{uri_path}"}]'
          }
      }
      if [type] == "couchdb" and [couchdb_error] == "" {
          http {
              http_method => post
              url => "http://monit-logs.cern.ch:10012/"
              #url => "http://monit-logsource-00acb7ff81.cern.ch:10012/"
              content_type => "application/json; charset=UTF-8"
              format => "message"
              message => '[{"producer": "cmswebk8s", "type": "couchdb", "hostname": "%{hostname}", "agent_id": "%{agent_id}", "ephemeral_id": "%{ephemeral_id}", "cmsweb_log": "%{cmsweb_log}", "message": "%{message}", "clientip":"%{clientip}", "method":"%{method}", "request":"%{request}", "rec_timestamp":"%{rec_timestamp}", "rec_date":"%{rec_date}", "log_level":"%{log_level}", "code":%{code}, "system":"%{system}", "uri_path":"%{uri_path}", "uri_params":"%{uri_params}", "uri_path":"%{uri_path}", "api":"%{api}"}]'
          }
      }
      if [type] == "dbs" and [dbs_error] == "" {
          http {
              http_method => post
              url => "http://monit-logs.cern.ch:10012/"
              #url => "http://monit-logsource-00acb7ff81.cern.ch:10012/"
              content_type => "application/json; charset=UTF-8"
              format => "message"
              message => '[{"producer": "cmswebk8s", "type": "dbs", "hostname": "%{hostname}", "agent_id": "%{agent_id}", "ephemeral_id": "%{ephemeral_id}", "cmsweb_log": "%{cmsweb_log}", "message": "%{message}", "tstamp": "%{tstamp}", "backend": "%{backend}", "clientip": "%{clientip}", "method":"%{method}", "httpversion":"%{httpversion}", "code":%{code}, "status":"%{status}", "auth":"%{auth}", "dn":"%{dn}", "client_agent":"%{client_agent}", "instance":"%{instance}", "instance_type":"%{instance_type}", "api":"%{api}", "params":"%{params}", "request":"%{request}", "rec_timestamp":"%{rec_timestamp}", "rec_date":"%{rec_date}"}]'
          }
      }
      if [type] == "reqmgr2" and [reqmgr2_error] == "" {
          http {
              http_method => post
              url => "http://monit-logs.cern.ch:10012/"
              #url => "http://monit-logsource-00acb7ff81.cern.ch:10012/"
              content_type => "application/json; charset=UTF-8"
              format => "message"
              message => '[{"producer": "cmswebk8s", "type": "reqmgr2", "hostname": "%{hostname}", "agent_id": "%{agent_id}", "ephemeral_id": "%{ephemeral_id}", "cmsweb_log": "%{cmsweb_log}", "message": "%{message}", "tstamp": "%{tstamp}", "backend": "%{backend}", "clientip": "%{clientip}", "method":"%{method}", "httpversion":"%{httpversion}", "code":%{code}, "status":"%{status}", "auth":"%{auth}", "dn":"%{dn}", "client_agent":"%{client_agent}", "request":"%{request}", "rec_timestamp":"%{rec_timestamp}", "rec_date":"%{rec_date}"}]'
          }
      }
      
      # uncomment this line if we need to debug messages
      #if [error] != "" {
      #    file {
      #        path => "/tmp/logstash-errors.log"
      #    }
      #    #stdout { codec => rubydebug }
      #}
    } # end of the output

  logstash.yml: |-
    http.host: "0.0.0.0"
    path.config: /usr/share/logstash/pipeline
    #xpack.monitoring.enabled: false
---
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: logstash
  namespace: monitoring
spec:
  template:
    metadata:
      labels:
        app: logstash
    spec:
      containers:
      - image: docker.elastic.co/logstash/logstash:5.5.0
        name: logstash
        ports:
        - name: logstash
          containerPort: 5044
          protocol: TCP
        volumeMounts:
        - name: config
          mountPath: /usr/share/logstash/config/logstash.yml
          subPath: logstash.yml
          readOnly: true
        - name: pipeline
          mountPath: /usr/share/logstash/pipeline
          readOnly: true
        args:
        - -f
        - /usr/share/logstash/pipeline/logstash.conf
        resources:
          limits:
            memory: 2Gi
            cpu: "200m"
          requests:
            memory: 2Gi
            cpu: "200m"
      volumes:
      - name: pipeline
        configMap:
          name: logstash
          items:
          - key: logstash.conf
            path: logstash.conf
      - name: config
        configMap:
          name: logstash
          items:
          - key: logstash.yml
            path: logstash.yml
---
apiVersion: v1
kind: Service
metadata:
  name: logstash
  namespace: monitoring
  labels:
    app: logstash
spec:
  selector:
    app: logstash
  ports:
  - name: logstash
    port: 5044
    targetPort: 5044
    protocol: TCP
